; The layout of this file roughly matches: https://clojure.org/api/cheatsheet

; Namespace management.
(def *ns*)
(def in-ns)

; Macros.
(def macroexpand-1
  (fn* [form]
    (native/raw "__value = __rt_ctx.macroexpand1(#{ form }#);")))
(def macroexpand
  (fn* [form]
    (native/raw "__value = __rt_ctx.macroexpand(#{ form }#);")))

; Primitives.
;; Arithmetic.
(def +)
(def -)
(def *)
(def /)
(def =)
(def <)

;; Numbers.
(def integer?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_integer() != nullptr)")))
(def float?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_real() != nullptr)")))
(def boolean?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_boolean() != nullptr)")))
(def number?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_number() != nullptr)")))

(def even?
  (fn* [o]
    (if (integer? o)
      (native/raw "__value = make_box(#{ o }#->as_integer()->data % 2 == 0)")
      ; TODO: throw an error
      false)))
(def odd?
  (fn* [o]
    (if (integer? o)
      (native/raw "__value = make_box(#{ o }#->as_integer()->data % 2 == 1)")
      ; TODO: throw an error
      false)))

; Relations.
;; Miscellaneous.
(def true?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ true }#) ? #{ true }# : #{ false }#")))
(def false?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ false }#) ? #{ true }# : #{ false }#")))
(def nil?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ nil }#) ? #{ true }# : #{ false }#")))

;; Collections.
(def empty?
  (fn* [o]
    (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                 if(!seqable)
                 { throw #{ :not-seqable }#; }
                 auto const &seq(seqable->seq());
                 __value = make_box(seq == nullptr);")))

;; Lists.
(def first
  (fn* [o]
    (if (nil? o)
      nil
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ nil }#; }
                   else
                   { __value = seq->first(); }"))))
(def next
  (fn* [o]
    (if (nil? o)
      nil
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ '() }#; }
                   else
                   { __value = seq->next_in_place(); }"))))
(def rest
  (fn* [o]
    (if (nil? o)
      '()
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ '() }#; }
                   else
                   {
                    __value = seq->next_in_place();
                    if(__value == nullptr)
                    { __value = #{ '() }#; }
                   }"))))
(def cons
  (fn* [head tail]
    (native/raw "auto const * const seqable_tail(#{ tail }#->as_seqable());
                 if(seqable_tail)
                 { __value = make_box<jank::runtime::obj::cons>(#{ head }#, seqable_tail->seq()); }
                 else if(#{ tail }#->as_nil())
                 { __value = make_box<jank::runtime::obj::cons>(#{ head }#, nullptr); }
                 else
                 { throw #{ :invalid-cons-tail }#; }")))
(def list
  (fn* [& items]
    (native/raw "auto * const seq(static_cast<behavior::sequence*>(const_cast<behavior::seqable*>(#{ items }#->as_seqable())));
                 __value = jank::runtime::obj::list::create(seq);")))
(def vec
  (fn* [coll]
    (native/raw "auto * const seq(static_cast<behavior::sequence*>(const_cast<behavior::seqable*>(#{ coll }#->as_seqable())));
                 __value = jank::runtime::obj::vector::create(seq);")))

;; Other.
(def hash
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->to_hash());")))

;; Strings.
(def string?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_string() != nullptr);")))
(def str
  (fn*
    ([]
     "")
    ([o]
     (native/raw "__value = make_box(#{ o }#->to_string());"))
    ([o & args]
     (native/raw "fmt::memory_buffer buff;
                  buff.reserve(16);
                  auto * const seq(static_cast<behavior::sequence*>(const_cast<behavior::seqable*>(#{ args }#->as_seqable())));
                  #{ o }#->to_string(buff);
                  seq->first()->to_string(buff);
                  for(auto *it(seq->next_in_place()); it != nullptr; it = it->next_in_place())
                  { it->first()->to_string(buff); }
                  __value = make_box<obj::string>(native_string{ buff.data(), buff.size() });"))))

;; Other.
(def keyword?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_keyword() != nullptr)")))
(def simple-keyword?
  (fn* [o]
    (native/raw "auto const * const k(#{ o }#->as_keyword());
                 __value = make_box(k != nullptr && k->sym.ns.empty())")))
(def qualified-keyword?
  (fn* [o]
    (native/raw "auto const * const k(#{ o }#->as_keyword());
                 __value = make_box(k != nullptr && !k->sym.ns.empty())")))
(def simple-symbol?
  (fn* [o]
    (native/raw "auto const * const sym(#{ o }#->as_symbol());
                 __value = make_box(sym != nullptr && sym->ns.empty())")))
(def qualified-symbol?
  (fn* [o]
    (native/raw "auto const * const sym(#{ o }#->as_symbol());
                 __value = make_box(sym != nullptr && !sym->ns.empty())")))
(def symbol?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_symbol() != nullptr)")))

; Sequences.
;; Associative.
;;; Common.
; TODO: get

; TODO: Higher arities. Needs clojure.core/spread, which needs clojure.core/cons.
(def apply
  (fn* [f args]
    (native/raw "auto const * const c(#{ f }#->as_callable());
                 if(!c)
                 { throw #{ :not-callable }#; }
                 __value = jank::runtime::apply_to(#{ f }#, #{ args }#);")))

; Input/output.
(def print
  (fn* [o]
    (native/raw "std::cout << #{ o }#->to_string();
                 __value = #{ nil }#;")))
(def println
  (fn* [& args]
    ; TODO: Move println back into here once I sort out two things:
    ; 1. Escaped strings, so I can do the space in between each
    ; 2. The linker errors showing up when using fmt::format_to here
    (native/raw "__value = __rt_ctx.println(#{ args }#);")))

; Functions.
(def ifn?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_callable() != nullptr)")))
(def fn?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_function() != nullptr)")))

; Miscellaneous.
; TODO: This should be a macro.
(def assert)

; Metadata
(def meta
  (fn* [o]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 if(md == nullptr || md->meta.is_none())
                 { __value = #{ nil }#; }
                 else
                 { __value = md->meta.unwrap(); }")))
(def with-meta
  (fn* [o m]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 // TODO: Standard exception handling.
                 if(md == nullptr)
                 { throw #{ :not-metadatable }#; }
                 __value = md->with_meta(#{ m }#);")))
(def reset-meta!
  (fn* [o m]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 // TODO: Standard exception handling.
                 if(md == nullptr)
                 { throw #{ :not-metadatable }#; }
                 behavior::metadatable::validate_meta(#{ m }#);
                 const_cast<behavior::metadatable*>(md)->meta = #{ m }#;
                 __value = #{ m }#;")))

(def defn
  (fn* [&form &env fn-name fn-args & body]
    (list 'def fn-name (cons 'fn* (cons fn-args body)))))
(reset-meta! (var defn) {:macro true})

(defn defmacro [&form &env fn-name fn-args & body]
  (list 'do
        (list 'def fn-name (cons 'fn* (cons (vec (cons '&form (cons '&env fn-args))) body)))
        (list 'reset-meta! (list 'var fn-name) {:macro true})))
(reset-meta! (var defmacro) {:macro true})

(defmacro when [condition & body]
  (list 'if condition
        (cons 'do body)
        nil))

;; jank.compiler things.
(def benchmark
  ; TODO: Options, following what criterium offers.
  (fn* [label fun]
    (native/raw "auto const * const label_str(#{ (str label) }#->as_string());
                 auto const * const callable(#{ fun }#->as_callable());
                 if(!callable)
                 { throw #{ :not-callable }#; }

                 ankerl::nanobench::Config config;
                 //config.mTimeUnit = std::chrono::milliseconds{ 1 };
                 //config.mTimeUnitName = TODO
                 config.mMinEpochIterations = 500;
                 config.mOut = &std::cout;
                 config.mWarmup = 300;

                 ankerl::nanobench::Bench().config(config).run
                 (
                  static_cast<std::string>(label_str->data),
                  [&]
                  {
                    object_ptr res{ callable->call() };
                    ankerl::nanobench::doNotOptimizeAway(res);
                  }
                 );")))
