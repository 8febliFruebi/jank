; The layout of this file rougly matches: https://clojure.org/api/cheatsheet

; Namespace management.
(def *ns*)
(def in-ns)

; Primitives.
;; Arithmetic.
(def +)
(def -)
(def *)
(def /)
(def =)
(def <)

;; Numbers.
(def integer?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_integer() != nullptr)")))
(def float?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_real() != nullptr)")))
(def boolean?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_boolean() != nullptr)")))
(def number?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_number() != nullptr)")))

(def even?
  (fn* [o]
    (if (integer? o)
      (native/raw "__value = make_box(#{ o }#->as_integer()->data % 2 == 0)")
      ; TODO: throw an error
      false)))
(def odd?
  (fn* [o]
    (if (integer? o)
      (native/raw "__value = make_box(#{ o }#->as_integer()->data % 2 == 1)")
      ; TODO: throw an error
      false)))

; Relations.
;; Miscellaneous.
(def true?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ true }#) ? #{ true }# : #{ false }#")))
(def false?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ false }#) ? #{ true }# : #{ false }#")))
(def nil?
  (fn* [o]
    (native/raw "__value = #{ o }#->equal(*#{ nil }#) ? #{ true }# : #{ false }#")))

;; Collections.
(def empty?
  (fn* [o]
    (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                 if(!seqable)
                 { throw #{ :not-seqable }#; }
                 auto const &seq(seqable->seq());
                 __value = make_box(seq == nullptr);")))

;; Lists.
(def first
  (fn* [o]
    (if (nil? o)
      nil
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ nil }#; }
                   else
                   { __value = seq->first(); }"))))
(def next
  (fn* [o]
    (if (nil? o)
      nil
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ '() }#; }
                   else
                   { __value = seq->next(); }"))))
(def rest
  (fn* [o]
    (if (nil? o)
      '()
      (native/raw "auto const * const seqable(#{ o }#->as_seqable());
                   if(!seqable)
                   { throw #{ :not-seqable }#; }
                   auto const &seq(seqable->seq());
                   if(!seq)
                   { __value = #{ '() }#; }
                   else
                   {
                    __value = seq->next();
                    if(__value == nullptr)
                    { __value = #{ '() }#; }
                   }"))))

;; Other.
(def hash
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->to_hash());")))

;; Strings.
(def string?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_string() != nullptr);")))
(def str
  (fn*
    ([]
     "")
    ([o]
     (native/raw "__value = make_box(#{ o }#->to_string());"))
    ([o & args]
     (native/raw "std::string ret(#{ o }#->to_string().data);
                  auto const * const l(#{ args }#->as_list());
                  for(auto const &elem : l->data)
                  { ret += elem->to_string().data; }
                  __value = make_box(ret);"))))

;; Other.
(def keyword?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_keyword() != nullptr)")))
(def simple-keyword?
  (fn* [o]
    (native/raw "auto const * const k(#{ o }#->as_keyword());
                 __value = make_box(k != nullptr && k->sym.ns.empty())")))
(def qualified-keyword?
  (fn* [o]
    (native/raw "auto const * const k(#{ o }#->as_keyword());
                 __value = make_box(k != nullptr && !k->sym.ns.empty())")))
(def simple-symbol?
  (fn* [o]
    (native/raw "auto const * const sym(#{ o }#->as_symbol());
                 __value = make_box(sym != nullptr && sym->ns.empty())")))
(def qualified-symbol?
  (fn* [o]
    (native/raw "auto const * const sym(#{ o }#->as_symbol());
                 __value = make_box(sym != nullptr && !sym->ns.empty())")))
(def symbol?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_symbol() != nullptr)")))

; Sequences.
;; Associative.
;;; Common.
; TODO: get

; TODO: Higher arities. Needs clojure.core/spread, which needs clojure.core/cons.
(def apply
  (fn* [f args]
    (native/raw "auto const * const c(#{ f }#->as_callable());
                 if(!c)
                 { throw #{ :not-callable }#; }
                 __value = jank::runtime::apply_to(#{ f }#, #{ args }#);")))

; Input/output.
(def print
  (fn* [o]
    (native/raw "std::cout << #{ o }#->to_string();
                 __value = #{ nil }#")))
(def println
  (fn* [o]
    (native/raw "std::cout << #{ o }#->to_string() << std::endl;
                 __value = #{ nil }#")))

; Functions.
(def ifn?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_callable() != nullptr)")))
(def fn?
  (fn* [o]
    (native/raw "__value = make_box(#{ o }#->as_function() != nullptr)")))

; Miscellaneous.
; TODO: This should be a macro.
(def assert)

; Metadata
(def meta
  (fn* [o]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 if(md == nullptr || md->meta.is_none())
                 { __value = #{ nil }#; }
                 else
                 { __value = md->meta.unwrap(); }")))
(def with-meta
  (fn* [o m]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 // TODO: Standard exception handling.
                 if(md == nullptr)
                 { throw #{ :not-metadatable }#; }
                 __value = md->with_meta(#{ m }#);")))
(def reset-meta!
  (fn* [o m]
    (native/raw "auto const * const md(#{ o }#->as_metadatable());
                 // TODO: Standard exception handling.
                 if(md == nullptr)
                 { throw #{ :not-metadatable }#; }
                 behavior::metadatable::validate_meta(#{ m }#);
                 const_cast<behavior::metadatable*>(md)->meta = #{ m }#;
                 __value = #{ m }#;")))
