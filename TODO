**** what's needed to make jank usable: ****

adopt core.typed

investigate clojure.spec

tweak grammar to handle whitespace/comments properly

imports

basic stdlib (two layers: core and aux) -- core can run in kernel
  arithmetic, logic, bit ops
  basic IO
  persistent immutable data structures
  higher-order functions
  generics are the big issue
    use core.logic
      first use it for overload resolution

structs
  destructors
    specialize /std/destroy
      requires generics? just overloading?
  more tests!

read command-line arguments from a separate file
  don't bother with the target macro yet

** everything else: **
write the extra compilation args to a file

port to boot?

better logging
  timbre (allows profiling, too)

sanitize idents which are keywords in backend language

passing first class overloaded declared functions
  implicitly wrap every function identifier in a lambda
    (λ (& args) (∀)
      (apply func args))

remove function-call from grammar; just use lists
  it becomes unhelpful with macros

consider allowing param packs to not be last
  perform matching as needed
  (ƒ shout (s string &strings i int &ints) () ...)


use bind and declare as expressions

tests
  comments within forms
    including functions
  keywords
  per-commit performance?
    criterium benchmarking
  codegen
    returning an integer literal and a jank integer from an if should work
  code execution (functional tests)

targets
  each target has its own prelude
    c++
    bash
    opencl
    nix
    forth
    vimscript

  (#target c++
           (dependencies "gl/gl.h")
           (command-line "-ggdb -Og -lGL"))

  prelude isn't included until #target macro is used

allow keywords?
  each keyword is its own type
  useful in the case of policies?

^type within macros for first class types
  maybe no need for generic syntax for macros?

constraints on return types
  Allow dependent types there
  (ƒ foo () (:T-ret) where (^number? : (T-ret))
    42)

REPL
  online repl sandbox
  irc bot for #jank
  tests
