refactoring
  expect state

REPL
  online repl sandbox

"falsey" is not a valid ident!!!

test
  function referencing
    ambiguous error
  function binding
  calling from binding
  calling from indirect binding
    native and non-native
  closures (returning closures)
  ƒ as a function type

start with cons and lambdas
  list
  map
  filter
  reduce

custom types are dynamically allocated by default
  traits to control allocation? (later)
  reference counted a la shared_ptr
  copied on mutation
  explicit copy function as well

change comments to just need ; at the beginning
  allow comments anywhere in forms

operators
  !=
  logical or, and, not, etc

clojure is a huge inspiration

stdlib
  print print-line format
  not and or
  even? odd?
  map, reduce, filter
  vector
  list
  map
  tuple

null
  allow calling nullary functions with null
  allow null-typed bindings

syntax errors...?
  will the regex remain?
    need to map s-exprs to file positions

variadic generics
  working with parameter packs

lambdas / function objects
  (ƒ foo (func ƒ : ((integer) (integer))) ()
    (print (func 42)))
  (foo
    (λ (i integer) (auto)
      i))

Maybes?
  pattern matching
    replace car, cdr, cond, eq, atom
