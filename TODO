refactoring
  expect state

start with cons and lambdas
  list
  map
  reduce

custom types are dynamically allocated by default
  traits to control allocation? (later)
  reference counted a la shared_ptr
  copied on mutation
  explicit copy function as well

change comments to just need ; at the beginning

operators
  !=
  logical or, and, not, etc

clojure is a huge inspiration

stdlib
  print print-line format
  not and or
  even? odd?
  map, reduce, filter
  vector
  list
  map
  tuple

null
  allow calling nullary functions with null
  allow null-typed bindings

syntax errors...?
  will the regex remain?
    need to map s-exprs to file positions

members
  Swizzling with tuples and structs?
    (.x.y my_coord)

variadic generics
  working with parameter packs

lambdas
  type deduction?
    auto works, return type can be deduced
      auto works, return type can be deduced
  lambda => λ
    (ƒ foo (f ƒ : ((integer) (integer))) ()
      (print (f 42)))
    (foo
      (λ : ((i integer) (integer))
        i))

Maybes?
  pattern matching
    replace car, cdr, cond, eq, atom
