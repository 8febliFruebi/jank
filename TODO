allow keywords?
  each keyword is its own type
  useful in the case of policies?

static analysis on travis

separate interpret binary and read AST

^type within macros for first class types
  maybe no need for generic syntax?

macros
  function arguments aren't visible
  allow proper lists as macro arguments without quoting
    for emit as well?

tuple and variadic functions

update readme with new generic function/macro syntax

generic functions as macros
  old way:
    (ƒ show : (:T) (o T) ()
      (print o))
    (show : (integer) 0)
    (show 0)

  new way:
    (ƒ⊕ show (T Ɐ) (o T) ()
      (print o))
    (show : (integer) 0)
    (show 0)

    (generic-struct (T Ɐ)
      (data T))

emacs major mode

remove expect_function
  always look up definitions before calling?

constraints on return types
  Allow dependent types there
  (ƒ foo () (:T-ret) where (^number? : (T-ret))
    42)

literal_value has list
  should it be stored elsewhere?

tests for
  cons, first, last, count, list

fix vim highlighting of falsey

recursing in auto-typed functions is broken
  only an issue when recursing as a param to another function
  skip it and find the next returning body

add a function to builtin which adds all

unary - on integers and reals
  plus tests

REPL
  add repl trait and compile separate lib
    allow multiple definitions
  online repl sandbox
  irc bot for #jank
  tests for repl

closures
  explicitly copy from scope? this may be messy

custom types are dynamically allocated by default
  traits to control allocation? (later)
  reference counted a la shared_ptr
  copied on mutation
  explicit copy function as well

codegen from the AST s-expression
  C++14 or LLVM IR?

allow comments anywhere in forms

list destructuring
  as macro params

operators
  !=
  logical or, and, not, etc

stdlib
  print print-line format
  not and or
  even? odd?
  map, reduce, filter
  vector
  list
  map
  tuple

null
  allow null-typed bindings

syntax errors...?
  will the regex remain?
    need to map s-exprs to file positions
